# This file is automatically generated by ruby-ll. Manually changing this file
# is not recommended as any changes will be lost the next time this parser is
# re-generated.
require 'll/setup'

module Oga
module CSS
# AST parser for CSS expressions.
#
# This parser does _not_ build a CSS specific AST, instead it directly produces
# an XPath AST. This removes the need to transform the AST or generate
# corresponding XPath expressions as a String.
#
# Similar to {Oga::XPath::Parser} this parser only takes String instances as
# input.
#
# @api private
#
class Parser < LL::Driver
  CONFIG = LL::DriverConfig.new

  CONFIG.terminals = [
    :$EOF, # 0
    :T_IDENT, # 1
    :T_PIPE, # 2
    :T_LBRACK, # 3
    :T_RBRACK, # 4
    :T_COLON, # 5
    :T_SPACE, # 6
    :T_LPAREN, # 7
    :T_RPAREN, # 8
    :T_MINUS, # 9
    :T_EQ, # 10
    :T_SPACE_IN, # 11
    :T_STARTS_WITH, # 12
    :T_ENDS_WITH, # 13
    :T_IN, # 14
    :T_HYPHEN_IN, # 15
    :T_GREATER, # 16
    :T_TILDE, # 17
    :T_PLUS, # 18
    :T_NTH, # 19
    :T_INT, # 20
    :T_STRING, # 21
    :T_ODD, # 22
    :T_EVEN, # 23
    :T_DOT, # 24
    :T_HASH, # 25
    :T_COMMA, # 26
  ].freeze

  CONFIG.rules = [
    [3, 0, 0, 1], # 0
    [3, 1, 2, 0], # 1
    [3, 2, 4, 30, 6, 0, 0, 3], # 2
    [3, 3, 0, 3, 1, 26], # 3
    [3, 4, 8, 32, 8, 31, 0, 8], # 4
    [3, 5, 0, 5], # 5
    [3, 6, 8, 33, 0, 11], # 6
    [3, 7, 0, 3, 1, 6], # 7
    [3, 8, 0, 5], # 8
    [3, 9, 8, 34, 0, 6, 1, 16], # 9
    [3, 10, 8, 35, 0, 6, 1, 18], # 10
    [3, 11, 8, 36, 0, 6, 1, 17], # 11
    [3, 12, 8, 37, 0, 8], # 12
    [3, 13, 0, 11], # 13
    [3, 14, 0, 19], # 14
    [3, 15, 0, 18], # 15
    [3, 16, 0, 20], # 16
    [3, 17, 0, 9], # 17
    [3, 18, 8, 38, 1, 1], # 18
    [3, 19, 1, 1, 1, 2], # 19
    [3, 20, 4, 39, 6, 0, 0, 12], # 20
    [3, 21, 0, 7], # 21
    [3, 22, 0, 13], # 22
    [3, 23, 1, 4, 0, 14, 1, 3], # 23
    [3, 24, 0, 16], # 24
    [3, 25, 0, 9], # 25
    [3, 26, 8, 40, 0, 15], # 26
    [3, 27, 1, 10], # 27
    [3, 28, 1, 11], # 28
    [3, 29, 1, 12], # 29
    [3, 30, 1, 13], # 30
    [3, 31, 1, 14], # 31
    [3, 32, 1, 15], # 32
    [3, 33, 1, 1, 1, 24], # 33
    [3, 34, 1, 1, 1, 25], # 34
    [3, 35, 8, 41, 0, 21], # 35
    [3, 36, 1, 1, 1, 5], # 36
    [3, 37, 1, 8, 0, 23, 1, 7], # 37
    [3, 38, 0, 28], # 38
    [3, 39, 0, 29], # 39
    [3, 40, 0, 26], # 40
    [3, 41, 0, 3], # 41
    [3, 42, 1, 21], # 42
    [3, 43, 1, 20], # 43
    [3, 44, 8, 42, 0, 27], # 44
    [3, 45, 8, 43, 0, 27, 1, 9], # 45
    [3, 46, 8, 45, 8, 44, 0, 25], # 46
    [3, 47, 1, 19], # 47
    [3, 48, 1, 22], # 48
    [3, 49, 1, 23], # 49
    [3, 50, 0, 2], # 50
    [3, 51, 0, 11], # 51
    [3, 52, 0, 4], # 52
    [3, 53, 0, 4], # 53
    [3, 54, 0, 4], # 54
    [3, 55, 0, 4], # 55
    [3, 56, 0, 4], # 56
    [3, 57, 0, 11], # 57
    [3, 58, 0, 10], # 58
    [3, 59, 0, 12], # 59
    [3, 60, 0, 24, 0, 17], # 60
    [3, 61, 0, 22], # 61
    [3, 62, 0, 25], # 62
    [3, 63, 0, 25], # 63
    [3, 64, 0, 27], # 64
    [3, 65, 0, 25], # 65
  ].freeze

  CONFIG.table = [
    [1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1], # 0
    [-1, 2, -1, 2, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 2, 2, -1, -1, -1, -1, -1, 2, 2, -1], # 1
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3], # 2
    [-1, 4, -1, 6, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 5, 5, -1, -1, -1, -1, -1, 6, 6, -1], # 3
    [-1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 8, 8, -1, -1, -1, -1, -1, -1, -1, -1], # 4
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1], # 5
    [-1, 12, -1, 13, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13, 13, -1], # 6
    [-1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, 14, -1], # 7
    [-1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 8
    [-1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 9
    [-1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 10
    [-1, -1, -1, 20, -1, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, 20, -1], # 11
    [-1, -1, -1, 22, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, 21, -1], # 12
    [-1, -1, -1, 23, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 13
    [-1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 14
    [-1, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 15
    [-1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 16
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 17
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 33, -1, -1], # 18
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 34, -1], # 19
    [-1, -1, -1, -1, -1, 35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 20
    [-1, -1, -1, -1, -1, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 21
    [-1, -1, -1, -1, -1, -1, -1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 22
    [-1, 41, -1, 41, -1, 41, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, 41, 41, 41, 40, 40, -1, 38, 39, 41, 41, -1], # 23
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 42, -1, -1, -1, -1, -1], # 24
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, -1, -1, -1, -1, -1, -1], # 25
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, 45, -1, -1, -1, -1, -1, -1, -1, -1, -1, 44, 46, -1, -1, -1, -1, -1, -1], # 26
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, -1, -1, -1, -1, -1, -1, -1], # 27
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, -1, -1], # 28
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1], # 29
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50], # 30
    [-1, -1, -1, 51, -1, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 51, 51, -1], # 31
    [-1, -1, -1, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 52, 52, -1, -1, -1, -1, -1, -1, -1, -1], # 32
    [-1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53, 53, 53, -1, -1, -1, -1, -1, -1, -1, -1], # 33
    [-1, -1, -1, -1, -1, -1, 54, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, 54, 54, -1, -1, -1, -1, -1, -1, -1, -1], # 34
    [-1, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, 55, 55, 55, -1, -1, -1, -1, -1, -1, -1, -1], # 35
    [-1, -1, -1, -1, -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, 56, 56, -1, -1, -1, -1, -1, -1, -1, -1], # 36
    [-1, -1, -1, 57, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, 57, -1], # 37
    [-1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 38
    [-1, -1, -1, 59, -1, 59, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 59, 59, -1], # 39
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 60, 60, 60, 60, 60, 60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 40
    [-1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], # 41
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, -1, -1, -1], # 42
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 63, -1, -1, -1, -1, -1, -1], # 43
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, -1], # 44
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, -1, -1, -1, -1, -1], # 45
  ].freeze

  CONFIG.actions = [
    [:_rule_0, 1], # 0
    [:_rule_1, 0], # 1
    [:_rule_2, 2], # 2
    [:_rule_3, 2], # 3
    [:_rule_4, 3], # 4
    [:_rule_5, 1], # 5
    [:_rule_6, 2], # 6
    [:_rule_7, 2], # 7
    [:_rule_8, 1], # 8
    [:_rule_9, 3], # 9
    [:_rule_10, 3], # 10
    [:_rule_11, 3], # 11
    [:_rule_12, 2], # 12
    [:_rule_13, 1], # 13
    [:_rule_14, 1], # 14
    [:_rule_15, 1], # 15
    [:_rule_16, 1], # 16
    [:_rule_17, 1], # 17
    [:_rule_18, 2], # 18
    [:_rule_19, 2], # 19
    [:_rule_20, 2], # 20
    [:_rule_21, 1], # 21
    [:_rule_22, 1], # 22
    [:_rule_23, 3], # 23
    [:_rule_24, 1], # 24
    [:_rule_25, 1], # 25
    [:_rule_26, 2], # 26
    [:_rule_27, 1], # 27
    [:_rule_28, 1], # 28
    [:_rule_29, 1], # 29
    [:_rule_30, 1], # 30
    [:_rule_31, 1], # 31
    [:_rule_32, 1], # 32
    [:_rule_33, 2], # 33
    [:_rule_34, 2], # 34
    [:_rule_35, 2], # 35
    [:_rule_36, 2], # 36
    [:_rule_37, 3], # 37
    [:_rule_38, 1], # 38
    [:_rule_39, 1], # 39
    [:_rule_40, 1], # 40
    [:_rule_41, 1], # 41
    [:_rule_42, 1], # 42
    [:_rule_43, 1], # 43
    [:_rule_44, 2], # 44
    [:_rule_45, 3], # 45
    [:_rule_46, 3], # 46
    [:_rule_47, 1], # 47
    [:_rule_48, 1], # 48
    [:_rule_49, 1], # 49
    [:_rule_50, 1], # 50
    [:_rule_51, 1], # 51
    [:_rule_52, 1], # 52
    [:_rule_53, 1], # 53
    [:_rule_54, 1], # 54
    [:_rule_55, 1], # 55
    [:_rule_56, 1], # 56
    [:_rule_57, 1], # 57
    [:_rule_58, 1], # 58
    [:_rule_59, 1], # 59
    [:_rule_60, 2], # 60
    [:_rule_61, 1], # 61
    [:_rule_62, 1], # 62
    [:_rule_63, 1], # 63
    [:_rule_64, 1], # 64
    [:_rule_65, 1], # 65
  ].freeze

  # @return [Oga::LRU]
  CACHE = LRU.new

  # @param [String] data
  # @return [AST::Node]
  def self.parse_with_cache(data)
    CACHE.get_or_set(data) { new(data).parse }
  end

  # @param [String] data The input to parse.
  def initialize(data)
    @lexer = Lexer.new(data)
  end

  # Resets the internal state of the parser.
  def reset
    @current_element = nil
  end

  # @param [Symbol] type
  # @param [Array] children
  # @return [AST::Node]
  def s(type, *children)
    AST::Node.new(type, children)
  end

  # Yields the next token from the lexer.
  #
  # @yieldparam [Array]
  def each_token
    @lexer.advance do |*args|
      yield args
    end

    yield [-1, -1]
  end

  # Returns the node test for the current element.
  #
  # @return [AST::Node]
  def current_element
    @current_element ||= s(:test, nil, '*')
  end

  # Parses the input and returns the corresponding AST.
  #
  # @example
  #  parser = Oga::CSS::Parser.new('foo.bar')
  #  ast    = parser.parse
  #
  # @return [AST::Node]
  def parse
    reset

    super
  end

  # Generates the AST for a node test.
  #
  # @param [String] namespace
  # @param [String] name
  # @return [AST::Node]
  def on_test(namespace, name)
    @current_element = s(:test, namespace, name)
  end

  # @param [String] name
  # @param [AST::Node] arg
  # @return [AST::Node]
  def on_pseudo_class(name, arg = nil)
    handler = "on_pseudo_class_#{name.gsub('-', '_')}"

    arg ? send(handler, arg) : send(handler)
  end

  # Generates the AST for the `root` pseudo class.
  #
  # @return [AST::Node]
  def on_pseudo_class_root
    s(:call, 'not', s(:axis, 'parent', s(:test, nil, '*')))
  end

  # Generates the AST for the `nth-child` pseudo class.
  #
  # @param [AST::Node] arg
  # @return [AST::Node]
  def on_pseudo_class_nth_child(arg)
    generate_nth_child('preceding-sibling', arg)
  end

  # Generates the AST for the `nth-last-child` pseudo class.
  #
  # @param [AST::Node] arg
  # @return [AST::Node]
  def on_pseudo_class_nth_last_child(arg)
    generate_nth_child('following-sibling', arg)
  end

  # Generates the AST for the `nth-of-type` pseudo class.
  #
  # @param [AST::Node] arg
  # @return [AST::Node]
  def on_pseudo_class_nth_of_type(arg)
    generate_nth_child('preceding-sibling', arg, current_element)
  end

  # Generates the AST for the `nth-last-of-type` pseudo class.
  #
  # @param [AST::Node] arg
  # @return [AST::Node]
  def on_pseudo_class_nth_last_of_type(arg)
    generate_nth_child('following-sibling', arg, current_element)
  end

  # Generates the AST for the `nth` pseudo class.
  #
  # @param [AST::Node] arg
  # @return [AST::Node]
  def on_pseudo_class_nth(arg)
    s(:eq, s(:call, 'position'), arg)
  end

  # Generates the AST for the `:first-child` selector.
  #
  # @return [AST::Node]
  def on_pseudo_class_first_child
    generate_no_siblings('preceding-sibling')
  end

  # Generates the AST for the `:last-child` selector.
  #
  # @return [AST::Node]
  def on_pseudo_class_last_child
    generate_no_siblings('following-sibling')
  end

  # Generates the AST for the `:first-of-type` selector.
  #
  # @return [AST::Node]
  def on_pseudo_class_first_of_type
    generate_no_siblings('preceding-sibling', current_element)
  end

  # Generates the AST for the `:last-of-type` selector.
  #
  # @return [AST::Node]
  def on_pseudo_class_last_of_type
    generate_no_siblings('following-sibling', current_element)
  end

  # Generates the AST for the `:only-child` selector.
  #
  # @return [AST::Node]
  def on_pseudo_class_only_child
    s(:and, on_pseudo_class_first_child, on_pseudo_class_last_child)
  end

  # Generates the AST for the `:only-of-type` selector.
  #
  # @return [AST::Node]
  def on_pseudo_class_only_of_type
    s(:and, on_pseudo_class_first_of_type, on_pseudo_class_last_of_type)
  end

  # Generates the AST for the `:empty` selector.
  #
  # @return [AST::Node]
  def on_pseudo_class_empty
    s(:call, 'not', s(:axis, 'child', s(:type_test, 'node')))
  end

  # Generates the AST for the `:not` selector.
  #
  # @param [AST::Node] arg
  # @return [AST::Node]
  def on_pseudo_class_not(arg)
    # Unpacks (axis "descendant" (test nil "x")) into just (test nil "x") as
    # in this case we want to wrap the (test) node in a (axis "self") node.
    if arg.type == :axis
      arg = s(:axis, 'self', arg.children[1])

    # Unpack (predicate (eq ...)) into just (eq)
    elsif arg.type == :predicate
      arg = arg.children[1]
    end

    s(:call, 'not', arg)
  end

  # Generates the AST for the `=` operator.
  #
  # @param [AST::Node] attr
  # @param [AST::Node] value
  # @return [AST::Node]
  def on_op_eq(attr, value)
    s(:eq, attr, value)
  end

  # Generates the AST for the `~=` operator.
  #
  # @param [AST::Node] attr
  # @param [AST::Node] value
  # @return [AST::Node]
  def on_op_space_in(attr, value)
    s(
      :call,
      'contains',
      s(:call, 'concat', s(:string, ' '), attr, s(:string, ' ')),
      s(:call, 'concat', s(:string, ' '), value, s(:string, ' '))
    )
  end

  # Generates the AST for the `^=` operator.
  #
  # @param [AST::Node] attr
  # @param [AST::Node] value
  # @return [AST::Node]
  def on_op_starts_with(attr, value)
    s(:call, 'starts-with', attr, value)
  end

  # Generates the AST for the `$=` operator.
  #
  # @param [AST::Node] attr
  # @param [AST::Node] value
  # @return [AST::Node]
  def on_op_ends_with(attr, value)
    s(
      :eq,
      s(
        :call,
        'substring',
        attr,
        s(
          :add,
          s(
            :sub,
            s(:call, 'string-length', attr),
            s(:call, 'string-length', value)
          ),
          s(:int, 1)
        ),
        s(:call, 'string-length', value)
      ),
      value
    )
  end

  # Generates the AST for the `*=` operator.
  #
  # @param [AST::Node] attr
  # @param [AST::Node] value
  # @return [AST::Node]
  def on_op_in(attr, value)
    s(:call, 'contains', attr, value)
  end

  # Generates the AST for the `|=` operator.
  #
  # @param [AST::Node] attr
  # @param [AST::Node] value
  # @return [AST::Node]
  def on_op_hyphen_in(attr, value)
    s(
      :or,
      s(:eq, attr, value),
      s(
        :call,
        'starts-with',
        attr,
        s(:call, 'concat', value, s(:string, '-'))
      )
    )
  end

  private

  # @param [String] count_axis
  # @param [AST::Node] arg
  # @param [AST::Node] count_test
  # @return [AST::Node]
  def generate_nth_child(count_axis, arg, count_test = s(:test, nil, '*'))
    count_call = s(:call, 'count', s(:axis, count_axis, count_test))

   # literal 2, 4, etc
    if int_node?(arg)
      node = s(:eq, count_call, s(:int, arg.children[0] - 1))
    else
      step, offset = *arg
      before_count = s(:add, count_call, s(:int, 1))
      compare      = step_comparison(step)

      # 2n+2, 2n-4, etc
      if offset
        mod_val = step_modulo_value(step)
        node    = s(
          :and,
          s(compare, before_count, offset),
          s(:eq, s(:mod, s(:sub, before_count, offset), mod_val), s(:int, 0))
        )

      # 2n, n, -2n
      else
        node = s(:eq, s(:mod, before_count, step), s(:int, 0))
      end
    end

    node
  end

  # @param [String] axis
  # @param [AST::Node] test
  # @return [AST::Node]
  def generate_no_siblings(axis, test = s(:test, nil, '*'))
    s(:eq, s(:call, 'count', s(:axis, axis, test)), s(:int, 0))
  end

  # @param [AST::Node] node
  # @return [TrueClass|FalseClass]
  def int_node?(node)
    node.type.equal?(:int)
  end

  # @param [AST::Node] node
  # @return [TrueClass|FalseClass]
  def non_positive_number?(node)
    node.children[0] <= 0
  end

  # @param [AST::Node] node
  # @return [Symbol]
  def step_comparison(node)
    node.children[0] >= 0 ? :gte : :lte
  end

  # @param [AST::Node] step
  # @return [AST::Node]
  def step_modulo_value(step)
    # -2n
    if step and non_positive_number?(step)
      mod_val = s(:int, -step.children[0])

    # 2n
    elsif step
      mod_val = step

    else
      mod_val = s(:int, 1)
    end

    mod_val
  end

  # @param [String] name
  # @param [AST::Node] test
  # @param [AST::Node] predicates
  # @param [AST::Node] more
  # @return [AST::Node]
  def generate_axis(name, test = nil, predicates = nil, more = nil)
    if test
      node = s(:axis, name, test)
    else
      node = s(:axis, name, on_test(nil, '*'))
    end

    if predicates
      node = s(:predicate, node, predicates)
    end

    node = add_child(node, more) if more

    node
  end

  # @param [AST::Node] node
  # @param [AST::Node] child
  # @return [AST::Node]
  def add_child(node, child)
    node.updated(nil, node.children + [child])
  end

  def _rule_0(val)
    val[0]
  end

  def _rule_1(val)
     nil 
  end

  def _rule_2(val)
    
      query = val[0]

      val[1].each do |chunk|
        query = s(:pipe, query, chunk)
      end

      query
    
  end

  def _rule_3(val)
     val[1] 
  end

  def _rule_4(val)
    
      node  = s(:axis, 'descendant', val[0])
      preds = val[1]
      more  = val[2]

      if preds
        node = s(:predicate, node, preds)
      end

      node = add_child(node, more) if more

      node
    
  end

  def _rule_5(val)
    val[0]
  end

  def _rule_6(val)
    
      node  = s(:axis, 'descendant', on_test(nil, '*'))
      preds = val[0]
      more  = val[1]

      if preds
        node = s(:predicate, node, preds)
      else
        node = s(:predicate, node)
      end

      node = add_child(node, more) if more

      node
    
  end

  def _rule_7(val)
     val[1] 
  end

  def _rule_8(val)
    val[0]
  end

  def _rule_9(val)
    
      test, preds = val[1]
      more        = val[2]

      generate_axis('child', test, preds, more)
    
  end

  def _rule_10(val)
    
      test, preds = val[1]
      more        = val[2]

      s(
        :predicate,
        s(:axis, 'following-sibling', on_test(nil, '*')),
        s(:int, 1),
        generate_axis('self', test, preds, more)
      )
    
  end

  def _rule_11(val)
    
      test, preds = val[1]
      more        = val[2]

      generate_axis('following-sibling', test, preds, more)
    
  end

  def _rule_12(val)
    val
  end

  def _rule_13(val)
     [nil, val[0]] 
  end

  def _rule_14(val)
    val[0]
  end

  def _rule_15(val)
    val[0]
  end

  def _rule_16(val)
    val[0]
  end

  def _rule_17(val)
     on_test(*val[0]) 
  end

  def _rule_18(val)
     val[1] ? [val[0], val[1]] : [nil, val[0]] 
  end

  def _rule_19(val)
     val[1] 
  end

  def _rule_20(val)
    
      ret = val[0]

      val[1].each do |pred|
        ret = s(:and, ret, pred)
      end

      ret
    
  end

  def _rule_21(val)
    val[0]
  end

  def _rule_22(val)
    val[0]
  end

  def _rule_23(val)
     val[1] 
  end

  def _rule_24(val)
    val[0]
  end

  def _rule_25(val)
     s(:axis, 'attribute', on_test(*val[0])) 
  end

  def _rule_26(val)
    
      op_type = val[1] ? val[1][0] : nil

      case op_type
      # a="b"
      when :eq
        on_op_eq(val[0], val[1][1])

      # a~="b"
      when :space_in
        on_op_space_in(val[0], val[1][1])

      # a^="b"
      when :starts_with
        on_op_starts_with(val[0], val[1][1])

      # a$="b"
      when :ends_with
        on_op_ends_with(val[0], val[1][1])

      # a*="b"
      when :in
        on_op_in(val[0], val[1][1])

      # a|="b"
      when :hyphen_in
        on_op_hyphen_in(val[0], val[1][1])

      else
        val[0]
      end
    
  end

  def _rule_27(val)
     :eq 
  end

  def _rule_28(val)
     :space_in 
  end

  def _rule_29(val)
     :starts_with 
  end

  def _rule_30(val)
     :ends_with 
  end

  def _rule_31(val)
     :in 
  end

  def _rule_32(val)
     :hyphen_in 
  end

  def _rule_33(val)
    
      axis = s(:axis, 'attribute', s(:test, nil, 'class'))

      s(
        :call,
        'contains',
        s(:call, 'concat', s(:string, ' '), axis, s(:string, ' ')),
        s(:string, " #{val[1]} ")
      )
    
  end

  def _rule_34(val)
    
      s(
        :eq,
        s(:axis, 'attribute', s(:test, nil, 'id')),
        s(:string, val[1])
      )
    
  end

  def _rule_35(val)
     on_pseudo_class(val[0], val[1]) 
  end

  def _rule_36(val)
     val[1] 
  end

  def _rule_37(val)
     val[1] 
  end

  def _rule_38(val)
    val[0]
  end

  def _rule_39(val)
    val[0]
  end

  def _rule_40(val)
    val[0]
  end

  def _rule_41(val)
    val[0]
  end

  def _rule_42(val)
     s(:string, val[0]) 
  end

  def _rule_43(val)
     s(:int, val[0].to_i) 
  end

  def _rule_44(val)
    
      val[1] ? s(:nth, s(:int, 1), val[1]) : s(:nth, s(:int, 1))
    
  end

  def _rule_45(val)
    
      val[2] ? s(:nth, s(:int, -1), val[2]) : s(:nth, s(:int, 1))
    
  end

  def _rule_46(val)
    
      # 2n+1
      if val[1] and val[2]
        a = val[0]
        b = val[2]

        # 2n-1 gets turned into 2n+1
        if b.children[0] < 0
          b = s(:int, a.children[0] - (b.children[0] % a.children[0]))
        end

        s(:nth, a, b)

      # 2n
      elsif val[1]
        s(:nth, val[0])

      # 2
      else
        val[0]
      end
    
  end

  def _rule_47(val)
     :nth 
  end

  def _rule_48(val)
     s(:nth, s(:int, 2), s(:int, 1)) 
  end

  def _rule_49(val)
     s(:nth, s(:int, 2)) 
  end

  def _rule_50(val)
    val[0]
  end

  def _rule_51(val)
    val[0]
  end

  def _rule_52(val)
    val[0]
  end

  def _rule_53(val)
    val[0]
  end

  def _rule_54(val)
    val[0]
  end

  def _rule_55(val)
    val[0]
  end

  def _rule_56(val)
    val[0]
  end

  def _rule_57(val)
    val[0]
  end

  def _rule_58(val)
    val[0]
  end

  def _rule_59(val)
    val[0]
  end

  def _rule_60(val)
    val
  end

  def _rule_61(val)
    val[0]
  end

  def _rule_62(val)
    val[0]
  end

  def _rule_63(val)
    val[0]
  end

  def _rule_64(val)
    val[0]
  end

  def _rule_65(val)
    val[0]
  end
end
end
end
